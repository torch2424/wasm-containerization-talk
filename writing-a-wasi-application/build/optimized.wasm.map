{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","assembly/index.ts","~lib/bindings/wasi_snapshot_preview1.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/string.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/arraybuffer.ts","~lib/util/error.ts","~lib/gc.ts"],"names":[],"mappings":"kUE4GE,AAAO,AAAC,AADG,cACwB,AAAC,EAAO,iBAC3C,EAAW,EAAO,MAElB,AAAoB,KAAW,YA+J/B,AAAI,EAAM,MAAa,AAAU,AAAkB,EAAM,WAOzD,AAAI,EAAM,MAAa,AAAU,AAAkB,EAAM,SMhPvD,AAAO,AAAkB,EAA0B,MAA0B,SCV7E,EAAkB,ICuHpB,AAAI,ADvHM,EAAK,KC8Hf,AAAI,EAAO,KACT,AACM,AAAC,EAAM,GAAO,EAAO,QACvB,AAAO,EAAO,KACZ,AAAI,AAAC,KACL,AAAE,OACQ,SAAiB,SAA3B,AAAU,EAAQ,AAAS,cAE7B,AAAO,EAAK,KACV,AAAW,EAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,YAId,IACY,SAAiB,SAA3B,AAAU,EAAQ,AAAS,QAC3B,AAAE,YAGJ,AACM,AAAC,EAAM,GAAO,EAAO,QACvB,AAAO,AAAC,EAAO,GAAK,KAClB,AAAI,AAAC,KACL,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,eAEvC,AAAO,EAAK,KAEV,AAAW,AAAO,AADlB,EAAK,KACM,GAAU,AAAU,EAAM,gBAI3C,IACE,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,oBFxHvC,AAAI,QAAwB,gBAIxB,AADiB,AAFC,IAAe,KAEL,AADT,IAAgB,eAEd,OAEzB,AAAY,AADF,AAA2B,EAAS,QACV,EAAyB,IAC7D,AAAY,EAAyB,GAAU,EAA0B,gBAojBvE,AAAa,AADA,EACS,AAAO,AAAkB,EAAyB,WAEjE,EAAS,KAEV,AADK,AAAe,OACf,MAGP,EAAU,IACD,EAAK,MACd,EAAU,IAEV,AAA+B,EAAS,GAAI,KAAxC,AAAC,EAAK,KAAW,QACnB,AAAI,AAAC,AAAe,KAAa,KAAW,OAC1C,EAAU,KAAG,EAAU,SAI3B,EAAU,OAEZ,EAAU,iBAOZ,AAAa,AADA,IACyB,AAAO,AAAkB,EAAyB,SAGxF,AAAa,AADH,AAAQ,AADL,AAAuB,MACV,MACP,KACnB,AAAa,MACb,AAAO,EAAS,KAEV,AADK,AAAe,OACf,MACP,AAAU,EAAQ,KAClB,MACS,EAAK,MAGd,AAAW,EAAQ,AAAU,AAFpB,EAAM,GAAI,IAEA,AADV,EAAK,GAAK,IACM,OACzB,EAAU,IAEV,AAA+B,EAAS,GAAI,KAAxC,AAAC,EAAK,KAAW,QAEnB,AAAI,AAAC,AADI,AAAe,OACd,KAAW,OAKnB,AAAS,AAJJ,AAAW,AAAC,EAAK,IAAW,GAA5B,KAAmC,EAAK,OAIzB,GAAK,MACzB,AAAW,EAAQ,AAAgC,AAJ1C,EAAM,GAAK,IAID,EAAM,GAAK,AAFrB,EAAM,GAAK,GAAK,IAEW,IAAK,AAHhC,EAAM,GAAK,GAAK,IAGsB,QAC/C,EAAU,KAAG,EAAU,SAO3B,AAAW,EAAQ,AAAU,AAHpB,EAAM,GAAK,IAGD,AAFV,EAAM,GAAK,GAAK,IAEA,OACzB,AAAU,EAAQ,AAFT,EAAW,GAAK,OAGzB,EAAU,OAEZ,EAAU,SAEZ,AAAO,EAAU,SAIV,UC9qBT,ECsLA,AAAI,ADtLW,KCuLf,AAAU,EAAM,KAChB,AAAU,EAAO,GAAI,GAAG,KACxB,AAAI,EAAK,KAET,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,KAAI,GAAG,KACxB,AAAU,EAAW,GAAG,KACxB,AAAI,EAAK,KACT,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,GAAI,GAAG,KACxB,AAAI,EAAK,KAKT,EAAK,AAFU,EAAC,GAAO,QAQvB,AAAW,AAPX,EAAQ,KAOS,KACjB,AAAW,EAAO,AANlB,EAAK,MAMiB,GAAG,KACzB,AAAI,EAAK,KACT,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,KAAI,GAAI,KAC1B,AAAW,EAAW,GAAG,KACzB,AAAI,EAAK,KACT,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,KAAI,GAAI,KAC1B,AAAW,EAAW,GAAI,KAC1B,AAAW,EAAW,GAAI,KAC1B,AAAW,EAAW,GAAI,KAI1B,EAAQ,AADJ,AAAM,EAAO,GAAb,QAEJ,EAAK,OAIL,AAAO,EAAK,KACV,AAAW,EAAM,KACjB,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,EAAK,KACL,EAAQ,eC1MV,AAAI,EAAc,aAElB,AAAY,AADC,AAAQ,EAAe,MACb,IAChB,SHOA,EAAqB,GAA4B,SJhD1D,AAAwB,SAAuB,cACG,MAOlD,AAAW,AAHiC,MAJ/B,KAQb,AAAW,EAAM,GAAiB,KAOlC,AAAS,EAAG,EAAK,EAAG,AAJ6B,gCAoBjD,AAAI,KACJ,AAAU,WDoOV,AAAkB,AADF,OACc,UAE9B,AAAkB,AADP,EAAY,KACG,KAAiB,EAAO,kBAalD,AAAkB,AATlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAKL,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MAEe,KAAW,EAAK,cAIvC,AAAW,OACX,AAAI,AAFO,SAED,EAAY,MACtB,AAAI,IAAM,EAAY,MAGtB,AAAI,EAAS,AApIX,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,UAqI5D,AA5HA,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA8HA,AAAI,AAAC,KAEH,AApJF,EAA2B,EAAM,IACjC,AAXF,AACE,EAA2B,EAAM,OA6JN,AAAE,EAAK,YAGhC,AAAI,AAAC,KAAO,OAAc,AAAE,EAAK,mBAzGrC,AAAkB,SAElB,AAAkB,AADF,OACc,UAM9B,AAAI,AAHY,AADJ,qBAII,KAEd,AAAI,AADU,AAAC,EAAY,GAAc,GAAkB,EAAY,MACzD,SACZ,AAAY,EAAM,IAClB,EAAe,AAAY,AAA0B,EAAzB,EAAY,SAE5B,AADJ,AArHa,EAA2B,GAAkB,KAAe,aA4HrF,AAAI,EAAY,KAGd,AAAkB,AADH,AADJ,AAnIM,EAA2B,aAqIf,UAE7B,AAAI,AADU,AAAC,EAAW,GAAc,GAAkB,EAAY,MACxD,WACZ,AAAY,EAAM,IAClB,EAAc,AAAY,AAAyB,EAAxB,EAAW,SAC9B,OAKZ,EAAe,EAAY,MAK3B,AAAkB,AADP,EAAY,KACG,KAAiB,EAAO,kBAClD,AAAkB,AAA4C,EAA5C,EAA2B,IAAyB,SAGtE,AAAa,EAA2B,GAAiB,KAazD,AAAkB,AATlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAKL,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MAEe,KAAW,EAAK,cA5FvC,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,SA+F9D,EAAa,KACb,EAFW,KAGX,AAAI,IAAM,EAAY,MACtB,AAzFE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA2FF,OAAe,EAAK,OACpB,AAhHE,EAA2B,EAAM,IACjC,AA+Gc,AAzHd,EAA2B,EAAM,OAyHA,EAAK,aAkHxC,AAII,AAAE,EAAM,MADR,AAAE,EAAQ,MADV,EAAS,YAQb,AAAI,AAFO,AA7MT,UAgNA,AAAkB,EAAS,EAA0B,UAGrD,AAAI,AAA0B,EAA1B,EAAQ,MAEV,AAAW,OADX,EAAS,OAON,AACE,EAAS,EAA0B,YAK5C,AAAI,AADO,EAAM,YAQjB,EAAc,AAAmB,EAAW,GAA9B,AAFC,EAAQ,GAEE,OACzB,EAAY,KACZ,EAAY,KAIZ,AADO,AAAkB,EAAQ,GAAO,KAC1B,KACd,AAtOE,EACA,MAuOF,AAAY,EAAM,UAmClB,AAAI,AAAC,AADM,OAKT,AAAI,AADc,EACA,AAFA,OAEe,AAAY,EAAc,KAAe,SAAG,EAE7E,AADO,KACM,KACb,GAAc,OACU,EAAK,KAC3B,SAAgB,KACX,AAAc,MAAG,EAAK,KACzB,eAAsB,KADY,AAAE,WAFF,AAAE,WAM9B,GAAM,GAA+C,EAAiB,KAChF,AAAO,WAtBT,AAAI,EAAQ,aACM,AAAC,EAAO,GAAW,mBAxHrC,AAAkB,AAdlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAMa,EAAO,SACrB,EAAQ,EAAM,EAAW,AAAW,MAAU,MAGlD,AAAK,AAAO,EAAgB,AADvB,EAAM,AAHO,MAIe,IAAa,KAC9C,EAAM,MAEe,KAAW,EAAK,cAKvC,AAAK,AAFO,WAAmB,EAAM,QAc5B,AA1LP,EAA2B,AAAC,AAAkB,AA0LZ,GA1LL,EAAM,IAAyB,QAiL5D,AAAK,AADO,KAAc,EAAO,EAAK,SAMpC,AAAkB,AADV,AAxMV,EAA2B,AAuMpB,AAAW,KAvMe,gBA0MxB,EAAkB,AAAS,iBAL3B,SAqGX,AAAI,AAAY,AAJhB,AAAkB,IAElB,AAAkB,AAAO,AAAC,AADlB,EAAkB,AAAqD,AAjQ7E,MAiQ8B,AAAC,EAAsB,GAAM,KAP7D,AAEE,EAAQ,AAAC,EAAM,EAAW,AAAW,KAAU,MAF7C,EAAO,SAQsB,KAAU,KAAa,aAEzB,KAC7B,AAAI,AAAY,IAAe,KAAG,GAG1B,EAAM,EAAsB,GAAI,EAAqB,UAxF/D,AAAgB,OAChB,AAAoB,EAAO,SAI3B,AAAI,AADY,AAAC,EAAY,GAAc,UAEzC,EAAe,EAAQ,EAAY,OAGnC,AADY,AAA8D,EAA5C,EAA2B,MAC1C,AAAC,EAAY,GAAkB,MAC9C,AAAY,EAAM,KAIlB,EAAe,EAAY,MAC3B,AAtRuB,EAA2B,GAAkB,KAAe,IAsRnF,iBAA0B,YA+G5B,AAAmB,QAGnB,AAAI,AAAC,AADO,AAAY,EAAM,AADZ,AAAY,aAI1B,AAAyB,IAEzB,AAAyB,IAEzB,AAAI,AAAC,AADG,AAAY,EAAM,SAExB,AAAW,EAAM,IAEjB,AAAkB,AADV,AAA8B,EAAM,eASlD,AAAkB,AAAC,QAA8B,SACjD,EAAe,KACf,EAAa,KACb,EAAe,KACf,AAAY,EAAM,IAClB,AAAa,EAAM,EAAc,SAkEjC,AAAO,AACS,EAAmB,EAAM,IACrC,MCliBJ,AAAI,UFmFJ,AAAS,AADE,OACK,SAEhB,AAAoB,KAAW,SAC/B,AAAI,EAAM,KACR,AAAgB,EAAuB,KAErC,AAAoB,EAAO,aCob/B,EAAe,AADC,KACW,MAC3B,AAAY,EAAM,KD3ahB,AAAkB,EAAK,SACvB,AACE,EAAW,AAA2B,EAAK,GAA/B,EAAO,mDAvEnB,EAAM,MAGR,AAAU,AAAkB,EAAM","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\nimport { TypeinfoFlags } from \"shared/typeinfo\";\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\n\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\n\n// ╒══════════════════════ GC Info structure ══════════════════════╕\n// │  3                   2                   1                    │\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │B│color│                     refCount                          │\n// └─┴─────┴───────────────────────────────────────────────────────┘\n// B: buffered\n\n// @ts-ignore: decorator\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\n// @ts-ignore: decorator\n@inline const COLOR_BITS = 3;\n// @ts-ignore: decorator\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\n// @ts-ignore: decorator\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\n\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\n// │ Color  │ Meaning                                              │\n// ├────────┼──────────────────────────────────────────────────────┤\n// │ BLACK  │ In use or free                                       │\n// │ GRAY   │ Possible member of cycle                             │\n// │ WHITE  │ Member of garbage cycle                              │\n// │ PURPLE │ Possible root of cycle                               │\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\n// └────────┴──────────────────────────────────────────────────────┘\n// Acyclic detection has been decoupled, hence no GREEN.\n\n// @ts-ignore: decorator\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\n\n// @ts-ignore: decorator\n@inline const VISIT_DECREMENT = 1; // guard 0\n// @ts-ignore: decorator\n@inline const VISIT_MARKGRAY = 2;\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 3;\n// @ts-ignore: decorator\n@inline const VISIT_SCANBLACK = 4;\n// @ts-ignore: decorator\n@inline const VISIT_COLLECTWHITE = 5;\n\n// @ts-ignore: decorator\n@global @unsafe @lazy\nfunction __visit(ref: usize, cookie: i32): void {\n  if (ref < __heap_base) return;\n  if (isDefined(__GC_ALL_ACYCLIC)) {\n    if (DEBUG) assert(cookie == VISIT_DECREMENT);\n    decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\n  } else {\n    let s = changetype<Block>(ref - BLOCK_OVERHEAD);\n    switch (cookie) {\n      case VISIT_DECREMENT: {\n        decrement(s);\n        break;\n      }\n      case VISIT_MARKGRAY: {\n        if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\n        s.gcInfo = s.gcInfo - 1;\n        markGray(s);\n        break;\n      }\n      case VISIT_SCAN: {\n        scan(s);\n        break;\n      }\n      case VISIT_SCANBLACK: {\n        let info = s.gcInfo;\n        assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n        s.gcInfo = info + 1;\n        if ((info & COLOR_MASK) != COLOR_BLACK) {\n          scanBlack(s);\n        }\n        break;\n      }\n      case VISIT_COLLECTWHITE: {\n        collectWhite(s);\n        break;\n      }\n      default: if (DEBUG) assert(false);\n    }\n  }\n}\n\n/** Increments the reference count of the specified block by one.*/\nfunction increment(s: Block): void {\n  var info = s.gcInfo;\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n  s.gcInfo = info + 1;\n  if (isDefined(ASC_RTRACE)) onincrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n}\n\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\n// @ts-ignore: decorator\n@lazy\nfunction decrement(s: Block): void {\n  var info = s.gcInfo;\n  var rc = info & REFCOUNT_MASK;\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n  if (rc == 1) {\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      if (DEBUG) assert(!(info & BUFFERED_MASK));\n      freeBlock(ROOT, s);\n    } else {\n      if (!(info & BUFFERED_MASK)) {\n        freeBlock(ROOT, s);\n      } else {\n        s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\n      }\n    }\n  } else {\n    if (DEBUG) assert(rc > 0);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n    } else {\n      if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\n        s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\n        if (!(info & BUFFERED_MASK)) {\n          appendRoot(s);\n        }\n      } else {\n        s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n      }\n    }\n  }\n}\n\n/** Buffer of possible roots. */\n// @ts-ignore: decorator\n@lazy var ROOTS: usize;\n/** Current absolute offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var CUR: usize = 0;\n/** Current absolute end offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var END: usize = 0;\n\n/** Appends a block to possible roots. */\nfunction appendRoot(s: Block): void {\n  var cur = CUR;\n  if (cur >= END) {\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\n    cur = CUR;\n  }\n  store<Block>(cur, s);\n  CUR = cur + sizeof<usize>();\n}\n\n/** Grows the roots buffer if it ran full. */\nfunction growRoots(): void {\n  var oldRoots = ROOTS;\n  var oldSize = CUR - oldRoots;\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\n  var newRoots = __alloc(newSize, 0);\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n  memory.copy(newRoots, oldRoots, oldSize);\n  if (oldRoots) {\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n    __free(oldRoots);\n  }\n  ROOTS = newRoots;\n  CUR = newRoots + oldSize;\n  END = newRoots + newSize;\n}\n\n/** Collects cyclic garbage. */\n// @ts-ignore: decorator\n@global @unsafe @lazy\nexport function __collect(): void {\n  if (isDefined(__GC_ALL_ACYCLIC)) return;\n\n  // markRoots\n  var roots = ROOTS;\n  var cur = roots;\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    let info = s.gcInfo;\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\n      markGray(s);\n      store<Block>(cur, s);\n      cur += sizeof<usize>();\n    } else {\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\n        freeBlock(ROOT, s);\n      } else {\n        s.gcInfo = info & ~BUFFERED_MASK;\n      }\n    }\n  }\n  CUR = cur;\n\n  // scanRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    scan(load<Block>(pos));\n  }\n\n  // collectRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\n    collectWhite(s);\n  }\n  CUR = roots;\n}\n\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\nfunction markGray(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\n  }\n}\n\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\nfunction scan(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\n    if ((info & REFCOUNT_MASK) > 0) {\n      scanBlack(s);\n    } else {\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\n    }\n  }\n}\n\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\nfunction scanBlack(s: Block): void {\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\n}\n\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\nfunction collectWhite(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\n    freeBlock(ROOT, s);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ptr: usize): usize {\n  if (ptr > __heap_base) increment(changetype<Block>(ptr - BLOCK_OVERHEAD));\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ptr: usize): void {\n  if (ptr > __heap_base) decrement(changetype<Block>(ptr - BLOCK_OVERHEAD));\n}\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\nimport { onfree, onalloc, onrealloc } from \"./rtrace\";\nimport { REFCOUNT_MASK } from \"./pure\";\n\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\n//                             see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\n// @ts-ignore: decorator\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\n// │                          size                           │0│L│F│ ◄─┐ info\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\n// │                                                               │   │\n// │               ... additional runtime overhead ...             │   │\n// │                                                               │   │\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │    = 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, right);\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\n      right = GETRIGHT(block);\n      rightInfo = right.mmInfo;\n      // 'back' is set below\n    }\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, left);\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\n      block = left;\n      // 'back' is set below\n    }\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) {\n    assert(\n      start <= end &&       // must be valid\n      !(start & AL_MASK) && // must be aligned\n      !(end & AL_MASK)      // must be aligned\n    );\n  }\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\n      start -= BLOCK_OVERHEAD;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\n}\n\n/** Initilizes the root structure. */\nexport function maybeInitialize(): Root {\n  var root = ROOT;\n  if (!root) {\n    const rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    root = changetype<Root>(rootOffset);\n    root.flMap = 0;\n    SETTAIL(root, changetype<Block>(0));\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      SETSL(root, fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        SETHEAD(root, fl, sl, null);\n      }\n    }\n    addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n    ROOT = root;\n  }\n  return root;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar collectLock: bool = false;\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize, id: u32): Block {\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    if (gc.auto) {\n      if (DEBUG) collectLock = true;\n      __collect();\n      if (DEBUG) collectLock = false;\n      block = searchBlock(root, payloadSize);\n      if (!block) {\n        growMemory(root, payloadSize);\n        block = changetype<Block>(searchBlock(root, payloadSize));\n        if (DEBUG) assert(block); // must be found now\n      }\n    } else {\n      growMemory(root, payloadSize);\n      block = changetype<Block>(searchBlock(root, payloadSize));\n      if (DEBUG) assert(block); // must be found now\n    }\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  block.gcInfo = 0; // RC=0\n  block.rtId = id;\n  block.rtSize = size;\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\n    prepareBlock(root, block, payloadSize);\n    block.rtSize = size;\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\n      // is immediately split though. does this trigger any assertions / issues?\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      block.rtSize = size;\n      prepareBlock(root, block, payloadSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  var newBlock = allocateBlock(root, size, block.rtId); // may invalidate cached blockInfo\n  newBlock.gcInfo = block.gcInfo; // keep RC\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onrealloc(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  block.mmInfo = blockInfo | FREE;\n  insertBlock(root, block);\n  if (isDefined(ASC_RTRACE)) onfree(block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ref: usize): Block {\n  var block = changetype<Block>(ref - BLOCK_OVERHEAD);\n  assert(\n    ref != 0 && !(ref & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE) &&        // must be used\n    !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize, id: u32): usize {\n  return changetype<usize>(\n    allocateBlock(maybeInitialize(), size, id)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ref: usize, size: usize): usize {\n  return changetype<usize>(\n    reallocateBlock(maybeInitialize(), checkUsedBlock(ref), size)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ref: usize): void {\n  freeBlock(maybeInitialize(), checkUsedBlock(ref));\n}\n","// Using raw WASI syscalls for demonstration purposes.\n// Use as-wasi for normal WASI Development.\n// https://github.com/jedisct1/as-wasi\n\nimport {\n  fd_write,\n  proc_exit\n} from \"bindings/wasi\";\n\nfunction log(s: string): void {\n\n  // Add a newline to the string\n  s += \"\\n\";\n\n  // Convert the string into a UTF8 byte buffer\n  let s_utf8_len: usize = String.UTF8.byteLength(s);\n  let s_utf8 = changetype<usize>(String.UTF8.encode(s));\n\n\n  // Allocate an array buffer in Wasm Memory\n  let iov = changetype<usize>(new ArrayBuffer(2 * sizeof<usize>()));\n\n  // Write the string buffer, into the allocated array buffer in Wasm Memory\n  store<u32>(iov, s_utf8);\n  store<u32>(iov + sizeof<usize>(), s_utf8_len);\n\n  // Get the length of an element in an array buffer\n  let iovs_len = changetype<usize>(new ArrayBuffer(sizeof<usize>()));\n\n  // Call the WASI fd_write syscall.\n  // First parameter is the file descriptor to write to. (1 -> /dev/stdout)\n  fd_write(1, iov, 1, iovs_len);\n}\n\n// Entry point into our module\nexport function _start(): void {\n  log(\"Hello WASI!\");\n}\n\n// Handle Aborting the program on errors.\n@global\nexport function wasi_abort(\n  message: string = \"\",\n  fileName: string = \"\",\n  lineNumber: u32 = 0,\n  columnNumber: u32 = 0\n): void {\n  log(\"Abort!\");\n  proc_exit(255);\n}\n","// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/snapshot/witx\n\n/* tslint:disable:max-line-length */\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** An event that occurred. */\n@unmanaged export abstract class event {\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n/* Information about a pre-opened capability. */\nexport abstract class prestat {\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\nexport class prestat_dir extends prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription {\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\nimport { ArrayBufferView } from \"../arraybuffer\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline\nconst POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline\nconst DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n// @ts-ignore: decorator\n@lazy @inline\nconst EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline\nconst FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return select<u32>(1, 2, value < 10);\n    } else {\n      let m = select<u32>(4, 5, value < 10000);\n      return select<u32>(3, m, value < 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return select<u32>(6, 7, value < 1000000);\n    } else {\n      let m = select<u32>(9, 10, value < 1000000000);\n      return select<u32>(8, m, value < 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      let m = select<u32>(11, 12, value < 100000000000);\n      return select<u32>(10, m, value < 10000000000);\n    } else {\n      let m = select<u32>(14, 15, value < 100000000000000);\n      return select<u32>(13, m, value < 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return select<u32>(16, 17, value < 10000000000000000);\n    } else {\n      let m = select<u32>(19, 20, value < 10000000000000000000);\n      return select<u32>(18, m, value < 1000000000000000000);\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + u32(sign);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var out: usize;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var out: usize;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n\n  return changetype<String>(out); // retains\n}\n\nexport function itoa<T extends number>(value: T): String {\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\n  if (isSigned<T>()) {\n    if (sizeof<T>() <= 4) {\n      return itoa32(<i32>value);\n    } else {\n      return itoa64(<i64>value);\n    }\n  } else {\n    if (sizeof<T>() <= 4) {\n      return utoa32(<u32>value);\n    } else {\n      return utoa64(<u64>value);\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = unchecked(FRC_POWERS[index]);\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = i32(value < 0);\n    if (sign) value = changetype<T>(-value);\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = i32(value < 0);\n      let len  = 8 + sign;\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// @ts-ignore\n@lazy const lowerTable127: u8[] = [\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n];\n\n// @ts-ignore\n@lazy const upperTable127: u8[] = [\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n];\n\n// @ts-ignore\n@lazy const lowerTable127Ptr = lowerTable127.dataStart as usize;\n// @ts-ignore\n@lazy const upperTable127Ptr = upperTable127.dataStart as usize;\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy const Powers10: f64[] = [\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n];\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\nexport function isSpace(c: i32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (u32(c - 0x09) <= 0x0D - 0x09);\n  }\n  if (u32(c - 0x2000) <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr + 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= <u32>radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return copysign<f64>(Infinity, sign);\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  // @ts-ignore: type\n  if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    ); // retains\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    offset += dtoa_stream(changetype<usize>(result), offset,\n      // @ts-ignore: type\n      value\n    );\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  offset += dtoa_stream(changetype<usize>(result), offset,\n    // @ts-ignore: type\n    value\n  );\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      result + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return changetype<string>(result); // retains\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  // @ts-ignore: cast\n  return load<f64>(Powers10.dataStart as usize + (n << alignof<f64>()));\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c & ~0x7F);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: i32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(lowerTable127Ptr + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: i32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(upperTable127Ptr + c);\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, toLower8, toUpper8 } from \"./util/string\";\nimport { specialsUpper, casemap, bsearch } from \"./util/casemap\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { idof } from \"./builtins\";\n\n@sealed export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<String>(out); // retains\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(out, lo | (hi << 16));\n    }\n    return changetype<String>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (intStart << 1), size);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, size);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<Array<String>>(__allocArray(length, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<Array<String>>(__allocArray(1, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 2 * 2, idof<String>());\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(codes + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(codes + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(codes + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(codes + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 3 * 2, idof<String>());\n    // @ts-ignore: cast\n    var specialsUpperPtr = specialsUpper.dataStart as usize;\n    var specialsUpperLen = specialsUpper.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(codes + (j << 1), c - 26);\n        } else {\n          let index = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsUpperPtr, specialsUpperLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsUpperPtr + (index << 1), 2);\n            let cc = load<u16>(specialsUpperPtr + (index << 1), 6);\n            store<u32>(codes + (j << 1), ab, 0);\n            store<u16>(codes + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(codes + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(codes + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var strOff = changetype<usize>(str);\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = <usize>UTF8.byteLength(str, nullTerminated);\n      var buf = __alloc(bufLen, idof<ArrayBuffer>());\n      var bufEnd = buf + bufLen - usize(nullTerminated);\n      var bufOff = buf;\n      while (bufOff < bufEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            let c2 = <u32>load<u16>(strOff, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; strOff += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        strOff += 2;\n      }\n      assert(strOff <= strEnd);\n      if (nullTerminated) {\n        store<u8>(bufOff, 0);\n      }\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<String>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var size = UTF16.byteLength(str);\n      var buf = __alloc(size, idof<ArrayBuffer>());\n      memory.copy(buf, changetype<usize>(str), <usize>size);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = __alloc(len &= ~1, idof<String>());\n      memory.copy(str, buf, len);\n      return changetype<String>(str); // retains\n    }\n  }\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = length;\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","/// <reference path=\"./rt/index.d.ts\" />\n\n/** Garbage collector interface. */\nexport namespace gc {\n\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\n  export var auto: bool = true;\n\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void {\n    __collect();\n  }\n}\n"]}